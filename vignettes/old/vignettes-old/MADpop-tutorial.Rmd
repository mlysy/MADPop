<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{Modeling of Variable-Alleled Species}
-->

Hierarchial Hardy-Weinberg Analysis of Variable Alleled Fish
========================================================
TUTORIAL
--------------------------------------------------------
There are many steps in this tutorial that are labelled STEP 1 to STEP 6. Each step has a "PURPOSE" written below for explanation of the step.
Throughout each of the steps there will be a "NOTE" as guidance.

```{r}
require(mapsAllele)
```

#
#
**STEP 0.**

PURPOSE: Clean up dataset. For a preloaded dataset, skip to STEP 1.

See mapsAllele/extdata/fish215-cleanup.R

#
#
**STEP 1.**
PURPOSE: Calculate some summary statistics for the data, to (1) simulate datasets which satisfy the Hardy-Weinberg equilibrium, and (2) draw MCMC samples for posterior inference. To proceed directly to inference go to step 2.

```{r}
# fish data
head(fish215)

# Here are two lakes under consideration: Simcoe and Michipicoten
lnames <- c("Simcoe", "Michipicoten")
Xobs <- fish215[fish215$Lake %in% lnames,]

```

Pool these under the null hypothesis:

H0: the two lakes have the same Hardy-Weinberg equilibrium conditions.

```{r}
Xsuff <- HW.suff(X = Xobs[,-1])
# converts the fish data Xobs into statistics including:
#   A: total set of unique alleles
#   G: total set of unique full genotypes (combination of 4 alleles)
#   Xg: counts in each unique genotype from observed data
#   H: total set of possible inherited genotypes (combination of 2 alleles)
#       with repeats being 1 inherited allele
#   Y: observed data in a simplified numerical format

```

This is the end of STEP 1. In STEP 1, we have sourced all of the functions we will be using, and loaded the model, as well as the fish215. In STEP 2, we will be working with the lake data to fit models using STAN.

#
#
**STEP 2.**

PURPOSE: to make inferences for two lakes under the null hypothesis. Null hypothesis is that the two lakes are the same, and they are not treated separately (grouped into one).

```{r}
# fit the model by STAN with 100,000 iterations
# The STAN model is the HardyWeinberg.stan file
nsamples <- 1e4
system.time({
  HW.fit <- HW.post(nsamples = nsamples, X = Xobs[,-1], chains = 1,
                    warmup = min(1e4, floor(nsamples/10)))
  rho.post <- HW.fit$rho
})

```

This is the end of STEP 2. STEP 3 will take these rho observations from HW and plot the results.

#
#
**STEP 3.**

PURPOSE: To display inferences for the null hypothesis  (H0)
- 1) Histogram
- 2) Box Plots

*1) Histograms*

Description: plots a histogram of the rho observations in HW.post

Each plot shows the number of observations on y-axis, and the values on the x-axis, for each individual rho - for a set of inherited genotype (2 alleles). The red line shows the average (mean) value of the rho observations, while the dotted red line represents the 95% C.I.

```{r}
nHobs <- nrow(Xsuff$H)
```

```{r, echo=FALSE}
if(FALSE) {
  par(mfrow = c(floor(sqrt(nHobs)), ceiling(nHobs/floor(sqrt(nHobs)))))
  par(mar = c(4.5,2,1,0)+.1)
  same.scale <- TRUE # set to false to give each plot its own x-axis
  if(same.scale) {
    rho.xlim <- range(rho.post)
  }
  for(ii in 1:nHobs) {
    nm <- paste0("rho[", paste(unique(Xsuff$H[ii,]), collapse = "*\".\"*"), "]",
                 collapse = "")
    if(!same.scale) {
      hist(rho.post[,ii], ylab = "", main = "",
           breaks = 100, freq = FALSE, xlab = parse(text = nm))
    } else {
      hist(rho.post[,ii], ylab = "", main = "", xlim = rho.xlim,
           breaks = 100, freq = FALSE, xlab = parse(text = nm))
    }
    # mean value and confidence interval (the red lines)
    abline(v = mean(rho.post[,ii]), col = "red")
    abline(v = quantile(rho.post[,ii], prob = c(.025, .975)), col = "red", lty = 2)
  }
}

```

*2) Boxplots*

Description: same result as above histogram, just different format

```{r}
par(mfrow = c(1,1), mar = c(5,4,4,2)+.1)
nm <- paste0("rho[", apply(Xsuff$H, 1,
                                function(a) paste(unique(a), collapse = "*\".\"*")), "]")
```

```{r, echo=FALSE}
boxplot(data.frame(rho.post), names = parse(text = nm), las = 2, ylab = "Probability")
```

This is the end of STEP 3. Starting from STEP 4, we calculate the test statistics under chi-square/lrt.

#
#
**STEP 4.**

PURPOSE: Now, calculate the chi-square and loglikelihood ratio test statistics. Please refer to notes on allele-functions to review: chi2.stat and LRT.stat functions.

We will be testing the null-hypothesis by calculating the p-values under two assumptions:
- 1) Unconstrained model
- 2) Hardy Weinberg constrained model

P-value is a function of the observed sample results. Based on the threshold level, if the p-value is less than (or equal) to the significance level, then the null hypothesis is rejected.

In this case, it will mean that the two lakes are not the same. In this section, we calculate the test statistics. A test statistic is a scalar function of all observations. It is used to quantify factors within the observed data that would distinguish null hypothesis from the alternate hypothesis.

NOTE: Testing deviations from Hardy Weinberg is generally performed using the Chi^2 test

```{r}
# Create a 2-way table with lakes as rows and observed genotypes as
#       columns (each observed genotype is given a unique identifier).
# tab.obs <- cbind(lake = as.character(Xobs[,1]),
#                  genotype = apply(Xsuff$Y, 1,
#                    function(x) paste0(sort(x), collapse = ".")))
# tab.obs <- table(tab.obs[,1], tab.obs[,2])
# tab.obs

tab.obs <- UM.suff(Xobs)$tab

```

```{r}
# observed statistics values
# functions used: chi2.stat and LRT.stat

T.obs <- c(chi2 = chi2.stat(tab.obs), LRT = LRT.stat(tab.obs))

# chi2 is the test statistic for chi^2
# LRT is the test statistic for likelihood ratio test
# p-values of the tests under H0: both lakes are the same

pchisq(T.obs, df = ncol(tab.obs)-1, lower.tail = FALSE)

```

Both fail to reject, but are very different in size. Yet, they are supposed to give almost identical p-values when there is enough data for the chi^2 approximation to kick in...

Please review the notes to the allele-functions file for explanation for how the test statistics are calculated.

This is the end of STEP 4. STEP 5 and 6 will be bootstrapping under unconstrained model and Hardy-Weinberg model respectively.

#
#
**STEP 5a.**

PURPOSE: bootstrapping under totally unconstrained model using MLE. 2 methods will be used to bootstrap distribution of statistics:
- 1) Unconstrained Model
- 2) Hardy-Weinberg Model (Step 6)

Two models are used because there are limited samples. Limited samples may result in data with many empty genotype observations. There are simply not even data to properly represent all the genotypes.

Thus, we want to observe the results using an unconstrained model, and the Hardy-Weinberg constrained model, which is more conservative. The HW Principle states that allele and genotype frequencies in a population will remain constant from generation to generation w/o other influences.

#
#
**First Method: totally Unconstrained Model**

- 1.  Estimate the common probability of observing each genotype assuming both lakes are the same.
- 2.  Randomly generate 2 independent lakes from this common distribution.
- 3.  Calculate the chi2 and LRT statistics for this simulated data
- 4.  Repeat steps 2 and 3 many times.
- 5.  Use the simulated histograms of chi2 and LRT to calculate the bootstrap p-values for each test.

NOTE: Bootstrapping refers to test that relies on random sampling with replacement. Bootstrapping allows estimation of the sampling distribution of any statistic, and makes inferences about a population from sample data.

```{r}
# number of repetitions will be 100,000
nreps <- 1e5

# Set p0 and N for the probability MLE and number of fish
p0 <- colSums(tab.obs)/sum(tab.obs) # MLE of common probability vector
N <- rowSums(tab.obs) # number of fish in each lake

```

```{r}
# Bootstrapping:
# Test statistic for chi2 and lrt
# 100,000 iterations
system.time({
  boot.out <- UM.eqtest(N1 = N[1], N2 = N[2], p0 = p0, nreps = nreps)
})

```

#
#
**STEP 5b.**

PURPOSE: to plot bootstrap results of the unconstrained model

PLOTS - plot the two tests chi2 and lrt side-by-side

```{r}
par(mfrow = c(1,2))
df0 <- length(p0)-1 # degrees of freedom
```

#
#
**1) Chi Squared**

```{r, echo=FALSE}

# xlim is the vector with minimum and maximum in the chi2.boot and chi2.obs
# histogram of bootstrap samples - plot looks like a distribution
# red line represents the observed value - to differentiate between samples and observed value

for(stat.nm in c("chi2", "LRT")) {
  # bootstrap  values
  hist(boot.out[,stat.nm], freq = FALSE, breaks = 100,
       xlim = range(boot.out[,stat.nm], T.obs[stat.nm]),
       main = ifelse(stat.nm == "chi2", "Chi-Square Test", "Likelihood Ratio Test"),
       xlab = ifelse(stat.nm == "chi2", expression(chi^2), expression(Lambda)))
  # observed value
  abline(v = T.obs[stat.nm], col = "red")
  # theoretical chi^2 distr most ppl use to calculate p-value
  curve(dchisq(x, df = df0), col = "blue", add = TRUE)
  # (dchisq gives the density)
  # (pchisq gives the distribution function)
  # The legend shows the p-value for both cases
  legend(x = "topleft",
         legend = c(paste("theoretical:",
           signif(pchisq(T.obs[stat.nm], df = df0, lower.tail = FALSE), 2)),
           paste("bootstrap:", signif(mean(boot.out[,stat.nm] >= T.obs[stat.nm]), 2))),
         title = "p-value", bty = "n")
}
```

This is the end of STEP 5. STEP 6 will now perform the same procedures, but under the Hardy-Weinberg model (in constrast to the unconstrained model in STEP 5).

#
#
**STEP 6a.**

PURPOSE: Same procedures as in STEP 5, but assuming the Hardy-Weinberg model - Bootstrap by generating data from the HW model.

**Second Method: Hardy-Weinberg model**

NOTE: states that allele and genotype frequencies in a population will remain constant from generation to generation in the absence of other evolutionary influences. Much more conservative - since more constrained.

Assuming 2 allele scenario: aa = p^2, Aa = 2p(1-p), AA = (1-p)^2

```{r}
# Bootstrapping:
# 100,000 iterations

system.time({
  boot.out2 <- HW.eqtest(N1 = N[1], N2 = N[2], H = Xsuff$H, rho = rho.post, nreps = nreps)
})
```


#
#
**STEP 6b.**
PURPOSE: to plot bootstrap results under HW model

```{r}
# Same plots as above, but put into for loop for graphing purposes
par(mfrow = c(1,2))
nbreaks <- 100

# degrees of freedom
df0 <- length(p0)-1
stat.nm <- c("chi^2", "Lambda")

```

```{r, echo=FALSE}
# For loop
for(ii in 1:2) {
  dens.cont <- density(boot.out[,ii]) # contingency table bootstrap
  hist.hw <- hist(boot.out2[,ii], breaks = 100, plot = FALSE)
  hist(boot.out2[,ii], freq = FALSE, breaks = 100,
       xlim = range(dens.cont$x, boot.out2[,ii], T.obs[ii]),
       ylim = range(dens.cont$y, hist.hw$density),
       main = parse(text = paste0("\"Distribution of \"*", stat.nm[ii], "*\" Statistic under \"*H[0]")),
       xlab = parse(text = stat.nm[ii])) # HW bootstrap
  lines(dens.cont$x, dens.cont$y, col = "red") # contingency table bootstrap
  # Observed value
  abline(v = T.obs[ii], col = "black", lwd = 2)
  # Theoretical chi^2 distr commonly used to calculate p-value
  curve(dchisq(x, df = df0), col = "blue", add = TRUE)
  # Legend with p-values
  pval <- signif(c(chi2 = pchisq(as.numeric(T.obs[ii]), df = df0, lower.tail = FALSE),
                   bcont = mean(boot.out[,ii] >= T.obs[ii]),
                   bHW = mean(boot.out2[,ii] >= T.obs[ii])), digits = 2)
  legend(x = "topleft",
         legend = parse(text = c("\"Test Statistic\"", "\"p-values\"",
                                 paste("\"Theoretical \"*(chi^2):", pval["chi2"]),
                                 paste("\"Bootstrap \"*(\"MLE\"):", pval["bcont"]),
                                 paste("\"Bootstrap \"*(\"Bayes-HW\"):", pval["bHW"]))),
         col = c("black", NA, "blue", "red", "black"),
         pch = c(NA, NA, NA, NA, 22),
         lty = c(1, NA, 1, 1, NA),
         lwd = c(2, NA, 1, 1, NA), cex = .8,
         bty = "o")
}

```


This is the end of STEP 6

#--- Hierarchical Unconstrained-Multinomial Model -------------------------------



############
############
############
############
############

```{r, echo=FALSE}
plot(cars)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
